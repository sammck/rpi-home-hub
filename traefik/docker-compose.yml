version: "3.3"

# docker-compose.yml configuration for a Traefik reverse-proxy with dashboard.
#
#  Environment Variables:
#    DEFAULT_RESOLVER         "prod" or "staging".  The default certificate resolver to use for
#                                 https services that do not specify a resolver.
#                                 "prod" uses real lets-encrypt certificates, "staging" uses staging lets-encrypt
#    TRAEFIK_RESOLVER         "prod" or "staging".  The certificate resolver to use for traefik.{PARENT_DNS_DOMAIN}
#                                 "prod" uses real lets-encrypt certificates, "staging" uses staging lets-encrypt
#    PARENT_DNS_DOMAIN       A registered public DNS domain that you control; e.g., "obama-family-home.com"
#                                 The dashboard will use a certificate for traefik.${PARENT_DNS_DOMAIN}
#    LETSENCRYPT_OWNER_EMAIL  The email address to associate with issued lets-encrypt certificataes
#    TRAEFIK_HTPASSWD         A comma-delimited list of username/hashed password values in the format
#                                 generated by `htpasswd`. The usernames and associated passwords in this
#                                 list will be able to access the Traefik dashboard.
#
# Entrypoints:
#    This stack creates a Traefik reverse-proxy with 5 entrypoints:
#
#    Entrypoint      Port   Description
#    ----------      ----   ---------------------------------
#    web             7080   Intended to serve public HTTP requests; public port 80 on the network's gateway
#                             router should be port-forwarded to this port. Also used to serve challenge
#                             requests from lets-encrypt to verify ownership of domain names.
#    websecure       7443   Intended to serve public HTTPS requests; public port 443 on the network's gateway
#                             router should be port-forwarded to this port.
#    lanweb            80   Serves HTTP requests for LAN-local clients
#    lanwebsecure     443   Serves HTTPS requests for LAN-local clients. to be used without certificate errors,
#                             A public DNS name must resolve externally to this network's public IP address,
#                             but must resolve within the LAN to this host's LAN IP address. This can be done
#                             by putting the LAN IP address in each client's /etc/hosts, or by hosting
#                             a LAN-local DNS server that overrides the public entries.
#    landashboard    8080   Serves the traefik dashboard on LAN-local http://<any-hostname>:8080.  Requires HTTP basic authentication.
#
# Externally, this stack serves:
#    http://traefik.${PARENT_DNS_DOMAIN}            Dashboard (private LAN only)
#    https://traefik.${PARENT_DNS_DOMAIN}           Dashboard (private LAN only)
#    http://<any-hostname>/traefik                   Dashboard (private LAN only)
#
#
# Prerequisites:
#   Prerequisites common to all stacks (only done once when traefik is initially set up):
#     * A DNS entry with a stable name (e.g., home.${DNS_DOMAIN}) has been configured to resolve to the current public IP address
#       of your network's gateway router. Since typical residential ISPs may change your public IP address periodically, it is
#       usually necessary to involve Dynamic DNS (DDNS) to make this work. Some gateway routers (e.g., eero) have DDNS support built-in.
#       Your DDNS provider will provide you with an obscure but unique and stable (as long as you stay with the DDNS provider)
#       DNS name for your gateway's public IP address; e.g., "g1234567.eero.online". You should then create a CNAME entry for
#       home.{DNS_DOMAIN} that points at the obscure DDNS name. That makes an easy-to-remember DNS name for your network's public IP
#       address, and ensures that if your DDNS obscure name ever changes, you will only have to update this one CNAME record
#       to be back in business.  
#     * A DNS CNAME entry has been created for traefik.${DNS_DOMAIN} that resolves to home.${PARENT_DNS_DOMAIN} (see above)
#       You must create a DNS entry for traefik.${DNS_DOMAIN} that resolves to your gateway router's public IP address
#       *before* starting this stack. If you do not, lets-encrypt will be unable to validate the certificate request,
#       and will eventually throttle you for a week at a time.
#     * Your network's gateway router must be configured to forward public ports 80 and 443 to this host on alternate destination ports
#       ports, as 80->7080 and 443->7443. Alternate ports are required because ports 80 and 443 on this host are used to serve
#       LAN-local (non-nternet) requests and must not be exposed to the internet. This must be done *before* starting this stack.
#       If you do not, lets-encrypt will be unable to validate the certificate request, and will eventually throttle you for a
#       week at a time.
#     * A persistent docker network "traefik" has been created before launching. This network is used by traefik to proxy requests to
#       backend service containers
#     * A persistent docker volume "traefik_acme" has been created before launching. This volume will contain cached issued
#       certificates from lets-encrypt it is very important that this data is not deleted and survives rebuild/restart
#       of traefik; lets-encrypt will block you for a period of time if you request reissuance of certificates that are not due for renewal.
services:
  traefik:
    # The traefik reverse proxy (includiong dashboard).
    #
    #  Configured to:
    #
    #    Use docker network "traefik" for backend connections to services behind the reverse-proxy
    #    Use lets-encrypt to automatically issue and renew SSL certificates. Persistence of lets-encrypt
    #      certificate state is kept in docker volume "traefik_acme", which should never be deleted.
    #    Serve public http:// on port 7080 (entrypoint "web").  This is port-forwarded to this host from my home's public IP
    #      address (on port 80) via eero port forwarding. This port is also used by lets-encrypt to verify that I have ownership of
    #      the server behind a DNS name when a new SSL certificate is issued.
    #    Serve public https:// on port 7443 (entrypoint "websecure"). This is port-forwarded to this host from my home's public IP
    #      address (on port 443) via eero port forwarding. Each hostname routed to this entrypoint is included in the SSL certificate(s) created
    #      by lets-encrypt. The Host rule's hostname MUST have a record in DNS that resolves to my home's public IP address before
    #      a valid SSL certificate can be created.
    #    Serve private (internal LAN only) http:// on port 80 (entrypoint "lanweb"). This port should NOT be exposed to the internet 
    #    Serve private (internal LAN only) https:// on port 443 (entrypoint "lansecureweb"). A self-signed certificate
    #      is used (not a valid certificate). This port should NOT be exposed to the internet.
    #    Serve a password-authenticated Traefik dashboard on http://traefik.${PARENT_DNS_DOMAIN}, https://traefik.${PARENT_DNS_DOMAIN},
    #      and "http://<any-hostname>/traefik", all for internal LAN only.
    #
    container_name: "traefik"
    image: "traefik:v2.10"
    restart: always
    command:
      - "--log.level=DEBUG"
      - "--accesslog=true"
      - "--api.dashboard=true"                       # Run a traefik dashboard on http://<this-host>:8080
      # - "--api.insecure=true"                        # dashboard is unsecured http
      - "--api.debug=true"
      - "--providers.docker=true"                    # Monitor docker container creation and automatically reverse-proxy to configured containers
      - "--providers.docker.network=traefik"         # Connect to proxied backend service containers through the "traefik" docker network. This ensures that
                                                     # there will be an IP route to the container's IP address if the container is on multiple
                                                     # networks.  Without it, traefik may pick an IP address of the container that is on another
                                                     # docker network which is not reachable from traefik's container.
      - "--providers.docker.exposedbydefault=false"  # require a "traefik.enable=true" label on containers behind reverse-proxy

      - "--entrypoints.web.address=:7080"                                      # Public http:// entrypoint (from gateway router port 80 forwarding)
      - "--entrypoints.websecure.address=:7443"                                # Public https:// entrypoint ( from gateway router port 443 forwarding)
      - "--entrypoints.websecure.http.tls.certResolver=resolver-${DEFAULT_RESOLVER}"
                                                                               # port 443 on LAN and public internet use lets-encrypt ACME tls resolver
      - "--entrypoints.lanweb.address=:80"                                     # Private LAN-only http:// entrypoint. Exposed to LAN.
      - "--entrypoints.lanwebsecure.address=:443"                              # Private https:// entrypoint. Exposed to LAN.
      - "--entrypoints.lanwebsecure.http.tls.certResolver=resolver-${DEFAULT_RESOLVER}"
                                                                               # Private LAN-only http://<any-host>:8080 entrypoint; used for LAN-local dashboard
      - "--entrypoints.landashboard.address=:8080"                             # Private LAN-only http://<host>:8080 entrypoint. Exposed to LAN.

      # "prod" certificate resolver uses real lets-encrypt certificates
      - "--certificatesresolvers.resolver-prod.acme.storage=/acme/acme_prod.json"
                                                                               # ACME state must be preserved so we put it in a Docker volume

      - "--certificatesresolvers.resolver-prod.acme.email=${LETSENCRYPT_OWNER_EMAIL}"
                                                                               # tell lets-encrypt who owns the DNS domain
      - "--certificatesresolvers.resolver-prod.acme.httpchallenge=true"
                                                                               # Use HTTP challenge protocol to verify ownership to lets-encrypt.
                                                                               #    lets-encrypt will send a challenge to http:<dns-name>:80/..."
                                                                               #    and traefik will respond with credentials. Then the cert will be issued.
      - "--certificatesresolvers.resolver-prod.acme.httpchallenge.entrypoint=web"
                                                                               # Use PUBLIC port 80 for ACME http challenges

      # "staging" certificate resolver uses staging lets-encrypt certificates
      - "--certificatesresolvers.resolver-staging.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory"
      - "--certificatesresolvers.resolver-staging.acme.storage=/acme/acme_staging.json"     
                                                                               # ACME state must be preserved so we put it in a Docker volume

      - "--certificatesresolvers.resolver-staging.acme.email=${LETSENCRYPT_OWNER_EMAIL}"
                                                                               # tell lets-encrypt who owns the DNS domain
      - "--certificatesresolvers.resolver-staging.acme.httpchallenge=true"     # Use HTTP challenge protocol to verify ownership to lets-encrypt.
                                                                               #    lets-encrypt will send a challenge to http:<dns-name>:80/..."
                                                                               #    and traefik will respond with credentials. Then the cert will be issued.
      - "--certificatesresolvers.resolver-staging.acme.httpchallenge.entrypoint=web"
                                                                               # Use PUBLIC port 80 for ACME http challenges

      # Plugins
      - "--experimental.plugins.trauth.moduleName=github.com/leonjza/trauth"   # An authentication plugin that uses HTTP BasicAuth once, then stores a cookie
                                                                               # can be used for simple website authentication that avoids repeated reauthentication.
      - "--experimental.plugins.trauth.version=v1.4.3"


      - "--experimental.plugins.trauth.moduleName=github.com/leonjza/trauth"   # An authentication plugin that uses HTTP BasicAuth once, then stores a cookie
                                                                               # can be used for simple website authentication that avoids repeated reauthentication.
      - "--experimental.plugins.trauth.version=v1.4.3"

    ports:
      - "7080:7080"   # Endpoint "web" -- Public http (exposed to internet on port 80 through eero port forwarding)
      - "7443:7443"   # Endpoint "secureweb" -- Public https (exposed to internet on port 443 through eero port forwarding)
      - "80:80"       # Endpoint "lanweb" -- Private http (exposed only to LAN)
      - "443:443"     # Endpoint "lanwebsecure" -- Private https (exposed only to LAN). self-signed SSL certificate.
      - "8080:8080"   # Endpoint "landashboard" -- Private http (exposed only to LAN) on port 8080. Serves only the Traefik dashboard,
                      #                            with basic authentication.
    volumes:
      - "/etc/localtime:/etc/localtime:ro"
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "traefik_acme:/acme"
    labels:
      # The labels here on the main traefik container allow us to add dynamic reverse-proxy
      # configuration for the Traefik dashboard, as if it were launched separately.
      - "traefik.enable=true"

      # A router for https://traefik.${PARENT_DNS_DOMAIN}
      # that only responds to LAN-local requests, and requires HTTP basic authentication.
      - "traefik.http.routers.traefik.entrypoints=lanwebsecure"
      - "traefik.http.routers.traefik.tls.certResolver=resolver-${TRAEFIK_RESOLVER}"
      - "traefik.http.routers.traefik.rule=Host(`traefik.${PARENT_DNS_DOMAIN}`) && (Path(`/`) || PathPrefix(`/api`,`/dashboard`))"
      - "traefik.http.routers.traefik.service=api@internal"
      - "traefik.http.routers.traefik.middlewares=traefik-auth"
      - "traefik.http.middlewares.traefik-auth.basicauth.users=${TRAEFIK_HTPASSWD}"

      # A router for http://traefik.${PARENT_DNS_DOMAIN} that redirects to https
      - "traefik.http.routers.traefik-redirect.entrypoints=lanweb"
      - "traefik.http.routers.traefik-redirect.rule=Host(`traefik.${PARENT_DNS_DOMAIN}`)"
      - "traefik.http.routers.traefik-redirect.service=api@internal"
      - "traefik.http.routers.traefik-redirect.middlewares=traefik-redirect-https"
      - "traefik.http.middlewares.traefik-redirect-https.redirectscheme.scheme=https"

      # A router for http://<any-hostname>:8080 that routes to the dashboard, and requires HTTP basic authentication.
      # LAN-local only.
      - "traefik.http.routers.traefik-dashboard.entrypoints=landashboard"
      - "traefik.http.routers.traefik-dashboard.rule=Path(`/`) || PathPrefix(`/api`,`/dashboard`)"
      - "traefik.http.routers.traefik-dashboard.service=api@internal"
      - "traefik.http.routers.traefik-dashboard.middlewares=traefik-auth"

    networks:
      - traefik

networks:
  traefik:
    # The backend network used for reverse-proxy request forwarding. All containers
    # that provide HTTP services behind the traefik reverse-proxy should be placed in
    # this network (normally serving on port 80). It is not necessary for containers
    # behind the reverse-proxy to expose their HTTP port to the host.
    external: true

volumes:
  traefik_acme:
    # Volume that contains acme.json, cached issued certificates from lets-encrypt
    # It is very important that this data is not deleted and survives rebuild/restart
    # of traefik; lets-encrypt will block you for a period of time if you request
    # reissuance of certificates that are not due for renewal.
    external:
      true
